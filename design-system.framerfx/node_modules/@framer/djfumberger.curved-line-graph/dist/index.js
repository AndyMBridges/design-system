(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("framer"), require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["framer", "react"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("framer"), require("react")) : factory(root["Framer"], root["React"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE_framer__, __WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		try { modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); } catch (error) { module.exports = { error } }
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// asset url
/******/ 	var __module_i = eval("typeof module !== 'undefined' ? module.i : ''");
/******/ 	var __framer_package = (/(node_modules[/].*)[/](build|dist).index.js/.exec(__module_i) || [])[1]
/******/ 	function __asset_url__(src) { return __WEBPACK_EXTERNAL_MODULE_framer__.serverURL(__framer_package, src) };
/******/ 	installedModules['framer/resource'] = { i: 'framer/resource', l: true, exports: { url: __asset_url__ } };
/******/
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./package.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./code sync recursive \\.(t|j)s(x?)|\\.css$":
/*!***************************************!*\
  !*** ./code sync \.(t|j)s(x?)|\.css$ ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./CurvedBezierGraph.tsx": "./code/CurvedBezierGraph.tsx",
	"./canvas.tsx": "./code/canvas.tsx"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	var module = __webpack_require__(id);
	return module;
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error('Cannot find module "' + req + '".');
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./code sync recursive \\.(t|j)s(x?)|\\.css$";

/***/ }),

/***/ "./code/CurvedBezierGraph.tsx":
/*!************************************!*\
  !*** ./code/CurvedBezierGraph.tsx ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __webpack_require__(/*! react */ \"react\");\nconst framer_1 = __webpack_require__(/*! framer */ \"framer\");\nclass CurvedLineGraph extends React.Component {\n    constructor() {\n        // Return the component contents in JSX\n        // https://reactjs.org/docs/introducing-jsx.html\n        super(...arguments);\n        this.containerRef = React.createRef();\n        this.canvasRef = React.createRef();\n        this.canvasHeight = 0;\n    }\n    render() {\n        window[\"__checkBudget__\"]();\n        return React.createElement(\"div\", { style: style, ref: this.containerRef },\n            React.createElement(\"canvas\", { ref: this.canvasRef }));\n    }\n    componentDidMount() {\n        window[\"__checkBudget__\"]();\n        this.update();\n    }\n    componentDidUpdate() {\n        window[\"__checkBudget__\"]();\n        this.update();\n    }\n    update() {\n        window[\"__checkBudget__\"]();\n        this.sizeGraph();\n        this.styleGraph();\n        this.updateGraph();\n    }\n    getContext() {\n        window[\"__checkBudget__\"]();\n        return this.canvasRef.current.getContext('2d');\n    }\n    sizeGraph() {\n        window[\"__checkBudget__\"]();\n        var canvas = this.canvasRef.current;\n        var dpr = 1; //window.devicePixelRatio || 1;\n        // Get the size of the canvas in CSS pixels.\n        var rect = canvas.getBoundingClientRect();\n        canvas.width = this.containerRef.current.offsetWidth * dpr;\n        canvas.height = this.containerRef.current.offsetHeight * dpr;\n        this.getContext().scale(dpr, dpr);\n        this.canvasHeight = canvas.height;\n    }\n    styleGraph() {\n        window[\"__checkBudget__\"]();\n    }\n    updateGraph() {\n        window[\"__checkBudget__\"]();\n        let ctx = this.getContext();\n        let values = this.props.points.split(\",\");\n        let dataPoints = values.map((yValue, i) => {\n            window[\"__checkBudget__\"]();\n            var x = i * this.props.xScale;\n            var y = (parseFloat(yValue) / this.props.yMax) * this.canvasHeight;\n            return new Point(x + this.props.xOffset, this.canvasHeight - y - Math.max(this.props.lineWidth, this.props.dotSize * 2) / 2);\n        });\n        let curvedLine = new CubicCurvedLine(dataPoints);\n        curvedLine.drawPath(ctx, this.props.xScale, this.props.lineColor, this.props.lineWidth);\n        if (this.props.showYLabels) {\n            curvedLine.drawYLabels(ctx, values, this.props.labelColor, this.props.labelYOffset - this.props.lineWidth);\n        }\n        if (this.props.showXLabels) {\n            let labels = this.props.labels.split(\",\");\n            curvedLine.drawXLabels(ctx, labels, this.props.labelColor, this.canvasHeight - 0);\n        }\n        if (this.props.showDots) {\n            curvedLine.drawDots(ctx, this.props.dotColor, this.props.dotSize);\n        }\n    }\n}\n// Set default values for props if there are none\n// https://reactjs.org/docs/react-component.html#defaultprops\nCurvedLineGraph.defaultProps = {\n    width: 375,\n    points: \"10,20,6,35\",\n    labels: \"a,b,c,d\",\n    // Graph\n    xScale: 100,\n    yMax: 75,\n    xOffset: 10,\n    // Line\n    lineColor: \"white\",\n    lineWidth: 5,\n    // Labels\n    showXLabels: false,\n    labelXColor: \"white\",\n    // Labels\n    showYLabels: false,\n    labelYOffset: -10,\n    labelColor: \"white\",\n    // Show dots\n    showDots: false,\n    dotSize: 4,\n    dotColor: \"white\"\n};\n// Add Framer UI for this component (in the properties panel)\n// https://framer.com/learn/docs/components#code\nCurvedLineGraph.propertyControls = {\n    points: { type: framer_1.ControlType.String, title: \"Points\" },\n    labels: { type: framer_1.ControlType.String, title: \"Labels\" },\n    xScale: { type: framer_1.ControlType.Number, title: \"X Scale\" },\n    yMax: { type: framer_1.ControlType.Number, title: \"Y Max\" },\n    xOffset: { type: framer_1.ControlType.Number, title: \"X Offset\", min: -1000, max: 1000 },\n    lineColor: { type: framer_1.ControlType.Color, title: \"Line Color\" },\n    lineWidth: { type: framer_1.ControlType.Number, title: \"Line Width\" },\n    showYLabels: { type: framer_1.ControlType.Boolean, title: \"Y Labels\" },\n    labelYOffset: { type: framer_1.ControlType.Number, title: \"Y Offset\", min: -50, max: 50,\n        hidden(props) { window[\"__checkBudget__\"](); return props.showYLabels == false; } },\n    showXLabels: { type: framer_1.ControlType.Boolean, title: \"X Labels\" },\n    labelColor: { type: framer_1.ControlType.Color, title: \"Label Color\",\n        hidden(props) { window[\"__checkBudget__\"](); return !(props.showXLabels == true || props.showYLabels == true); }\n    },\n    showDots: { type: framer_1.ControlType.Boolean, title: \"Show Dots\",\n    },\n    dotSize: { type: framer_1.ControlType.Number, title: \"Dot Size\",\n        hidden(props) { window[\"__checkBudget__\"](); return props.showDots == false; }\n    },\n    dotColor: { type: framer_1.ControlType.Color, title: \"Dot Color\",\n        hidden(props) { window[\"__checkBudget__\"](); return props.showDots == false; }\n    },\n};\nexports.CurvedLineGraph = CurvedLineGraph;\n// Define some standard CSS for your component\nconst style = {\n    height: \"100%\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    textAlign: \"center\",\n    color: \"#8855FF\",\n    overflow: \"hidden\"\n};\nclass Point {\n    constructor(x, y) {\n        this.x = 0;\n        this.y = 0;\n        window[\"__checkBudget__\"]();\n        this.x = x;\n        this.y = y;\n    }\n}\nclass CubicCurveSegment {\n    constructor(controlPoint1, controlPoint2) {\n        window[\"__checkBudget__\"]();\n        this.controlPoint1 = controlPoint1;\n        this.controlPoint2 = controlPoint2;\n    }\n}\nclass CubicCurvedLine {\n    constructor(dataPoints) {\n        this.firstControlPoints = [];\n        this.secondControlPoints = [];\n        this.dataPoints = [];\n        window[\"__checkBudget__\"]();\n        this.dataPoints = dataPoints;\n    }\n    drawPath(ctx, xScale, lineColor, lineWidth) {\n        window[\"__checkBudget__\"]();\n        let controlPoints = this.controlPoints();\n        ctx.beginPath();\n        ctx.strokeStyle = lineColor;\n        ctx.lineWidth = lineWidth;\n        ctx.lineCap = \"round\";\n        this.dataPoints.forEach((point, i) => {\n            window[\"__checkBudget__\"]();\n            if (i == 0) {\n                ctx.moveTo(point.x, point.y);\n            }\n            else {\n                let segment = controlPoints[i - 1];\n                var cp2 = segment.controlPoint2;\n                var cp1 = segment.controlPoint1;\n                ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, point.x, point.y);\n            }\n        });\n        ctx.stroke();\n    }\n    drawXLabels(ctx, labels, labelColor, offset) {\n        window[\"__checkBudget__\"]();\n        ctx.font = \"bold 14px SF Pro Display\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = labelColor;\n        this.dataPoints.forEach((point, i) => {\n            window[\"__checkBudget__\"]();\n            if (labels[i]) {\n                ctx.fillText(labels[i], point.x, offset);\n            }\n        });\n    }\n    drawYLabels(ctx, values, labelColor, offset) {\n        window[\"__checkBudget__\"]();\n        ctx.font = \"bold 14px SF Pro Display\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = labelColor;\n        this.dataPoints.forEach((point, i) => {\n            window[\"__checkBudget__\"]();\n            ctx.fillText(values[i], point.x, point.y + offset);\n        });\n    }\n    drawDots(ctx, dotColor, dotSize) {\n        window[\"__checkBudget__\"]();\n        ctx.fillStyle = dotColor;\n        this.dataPoints.forEach((point, i) => {\n            window[\"__checkBudget__\"]();\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, dotSize, 0, Math.PI * 2, false);\n            ctx.fill();\n        });\n    }\n    controlPoints() {\n        window[\"__checkBudget__\"]();\n        //Number of Segments\n        let count = this.dataPoints.length - 1;\n        if (count <= 0) {\n            return [];\n        }\n        //P0, P1, P2, P3 are the points for each segment, where P0 & P3 are the knots and P1, P2 are the control points.\n        if (count == 1) {\n            let P0 = this.dataPoints[0];\n            let P3 = this.dataPoints[1];\n            //Calculate First Control Point\n            //3P1 = 2P0 + P3\n            let P1x = (2 * P0.x + P3.x) / 3;\n            let P1y = (2 * P0.y + P3.y) / 3;\n            this.firstControlPoints.push(new Point(P1x, P1y));\n            //Calculate second Control Point\n            //P2 = 2P1 - P0\n            let P2x = (2 * P1x - P0.x);\n            let P2y = (2 * P1y - P0.y);\n            this.secondControlPoints.push(new Point(P2x, P2y));\n        }\n        else {\n            this.firstControlPoints = [];\n            var rhsArray = [];\n            //Array of Coefficients\n            var a = [];\n            var b = [];\n            var c = [];\n            //for i in 0...count-1 {\n            for (var i = 0; i < count; i++) {\n                window[\"__checkBudget__\"]();\n                var rhsValueX = 0;\n                var rhsValueY = 0;\n                let P0 = this.dataPoints[i];\n                let P3 = this.dataPoints[i + 1];\n                if (i == 0) {\n                    a.push(0);\n                    b.push(2);\n                    c.push(1);\n                    //rhs for first segment\n                    rhsValueX = P0.x + 2 * P3.x;\n                    rhsValueY = P0.y + 2 * P3.y;\n                }\n                else if (i == count - 1) {\n                    a.push(2);\n                    b.push(7);\n                    c.push(0);\n                    //rhs for last segment\n                    rhsValueX = 8 * P0.x + P3.x;\n                    rhsValueY = 8 * P0.y + P3.y;\n                }\n                else {\n                    a.push(1);\n                    b.push(4);\n                    c.push(1);\n                    rhsValueX = 4 * P0.x + 2 * P3.x;\n                    rhsValueY = 4 * P0.y + 2 * P3.y;\n                }\n                rhsArray.push(new Point(rhsValueX, rhsValueY));\n            }\n            //Solve Ax=B. Use Tridiagonal matrix algorithm a.k.a Thomas Algorithm\n            //for i in 1...count-1 { //\n            for (var i = 1; i < count; i++) {\n                window[\"__checkBudget__\"]();\n                let rhsValueX = rhsArray[i].x;\n                let rhsValueY = rhsArray[i].y;\n                let prevRhsValueX = rhsArray[i - 1].x;\n                let prevRhsValueY = rhsArray[i - 1].y;\n                let m = a[i] / b[i - 1];\n                let b1 = b[i] - m * c[i - 1];\n                b[i] = b1;\n                let r2x = rhsValueX - m * prevRhsValueX;\n                let r2y = rhsValueY - m * prevRhsValueY;\n                rhsArray[i] = new Point(r2x, r2y);\n            }\n            // Get First Control Points            \n            // Last control Point\n            let lastControlPointX = rhsArray[count - 1].x / b[count - 1];\n            let lastControlPointY = rhsArray[count - 1].y / b[count - 1];\n            this.firstControlPoints[count - 1] = new Point(lastControlPointX, lastControlPointY);\n            for (var i = count - 2; i >= 0; --i) {\n                window[\"__checkBudget__\"]();\n                let nextControlPoint = this.firstControlPoints[i + 1];\n                if (nextControlPoint) {\n                    let controlPointX = (rhsArray[i].x - c[i] * nextControlPoint.x) / b[i];\n                    let controlPointY = (rhsArray[i].y - c[i] * nextControlPoint.y) / b[i];\n                    this.firstControlPoints[i] = new Point(controlPointX, controlPointY);\n                }\n            }\n            //Compute second Control Points from first            \n            for (var i = 0; i < count; i++) {\n                window[\"__checkBudget__\"]();\n                if (i == count - 1) {\n                    let P3 = this.dataPoints[i + 1];\n                    let P1 = this.firstControlPoints[i];\n                    if (P1 == null) {\n                        continue;\n                    }\n                    let controlPointX = (P3.x + P1.x) / 2;\n                    let controlPointY = (P3.y + P1.y) / 2;\n                    this.secondControlPoints.push(new Point(controlPointX, controlPointY));\n                }\n                else {\n                    let P3 = this.dataPoints[i + 1];\n                    let nextP1 = this.firstControlPoints[i + 1];\n                    if (nextP1 == null) {\n                        continue;\n                    }\n                    let controlPointX = 2 * P3.x - nextP1.x;\n                    let controlPointY = 2 * P3.y - nextP1.y;\n                    this.secondControlPoints.push(new Point(controlPointX, controlPointY));\n                }\n            }\n        }\n        var controlPoints = [];\n        for (var i = 0; i < count; i++) {\n            window[\"__checkBudget__\"]();\n            let firstControlPoint = this.firstControlPoints[i];\n            let secondControlPoint = this.secondControlPoints[i];\n            let segment = new CubicCurveSegment(firstControlPoint, secondControlPoint);\n            controlPoints.push(segment);\n        }\n        return controlPoints;\n    }\n}\nexports.__info__ = [{ name: \"CurvedLineGraph\", children: false, type: \"component\" }];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb2RlL0N1cnZlZEJlemllckdyYXBoLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRiwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQXFEO0FBQ2xFLGFBQWEscURBQXFEO0FBQ2xFLGFBQWEsc0RBQXNEO0FBQ25FLFdBQVcsb0RBQW9EO0FBQy9ELGNBQWMsOEVBQThFO0FBQzVGLGdCQUFnQix3REFBd0Q7QUFDeEUsZ0JBQWdCLHlEQUF5RDtBQUN6RSxrQkFBa0Isd0RBQXdEO0FBQzFFLG1CQUFtQjtBQUNuQix1QkFBdUIsNkJBQTZCLG1DQUFtQyxFQUFFLEVBQUU7QUFDM0Ysa0JBQWtCLHdEQUF3RDtBQUMxRSxpQkFBaUI7QUFDakIsdUJBQXVCLDZCQUE2QixrRUFBa0U7QUFDdEgsS0FBSztBQUNMLGVBQWU7QUFDZixLQUFLO0FBQ0wsY0FBYztBQUNkLHVCQUF1Qiw2QkFBNkIsZ0NBQWdDO0FBQ3BGLEtBQUs7QUFDTCxlQUFlO0FBQ2YsdUJBQXVCLDZCQUE2QixnQ0FBZ0M7QUFDcEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQThEIiwiZmlsZSI6Ii4vY29kZS9DdXJ2ZWRCZXppZXJHcmFwaC50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgZnJhbWVyXzEgPSByZXF1aXJlKFwiZnJhbWVyXCIpO1xuY2xhc3MgQ3VydmVkTGluZUdyYXBoIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBjb21wb25lbnQgY29udGVudHMgaW4gSlNYXG4gICAgICAgIC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9pbnRyb2R1Y2luZy1qc3guaHRtbFxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNhbnZhc1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IDA7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlLCByZWY6IHRoaXMuY29udGFpbmVyUmVmIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHsgcmVmOiB0aGlzLmNhbnZhc1JlZiB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgdGhpcy5zaXplR3JhcGgoKTtcbiAgICAgICAgdGhpcy5zdHlsZUdyYXBoKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JhcGgoKTtcbiAgICB9XG4gICAgZ2V0Q29udGV4dCgpIHtcbiAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuICAgIHNpemVHcmFwaCgpIHtcbiAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICB2YXIgZHByID0gMTsgLy93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBpbiBDU1MgcGl4ZWxzLlxuICAgICAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5jb250YWluZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aCAqIGRwcjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQub2Zmc2V0SGVpZ2h0ICogZHByO1xuICAgICAgICB0aGlzLmdldENvbnRleHQoKS5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB9XG4gICAgc3R5bGVHcmFwaCgpIHtcbiAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgfVxuICAgIHVwZGF0ZUdyYXBoKCkge1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy5wcm9wcy5wb2ludHMuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgZGF0YVBvaW50cyA9IHZhbHVlcy5tYXAoKHlWYWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgICB2YXIgeCA9IGkgKiB0aGlzLnByb3BzLnhTY2FsZTtcbiAgICAgICAgICAgIHZhciB5ID0gKHBhcnNlRmxvYXQoeVZhbHVlKSAvIHRoaXMucHJvcHMueU1heCkgKiB0aGlzLmNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCArIHRoaXMucHJvcHMueE9mZnNldCwgdGhpcy5jYW52YXNIZWlnaHQgLSB5IC0gTWF0aC5tYXgodGhpcy5wcm9wcy5saW5lV2lkdGgsIHRoaXMucHJvcHMuZG90U2l6ZSAqIDIpIC8gMik7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY3VydmVkTGluZSA9IG5ldyBDdWJpY0N1cnZlZExpbmUoZGF0YVBvaW50cyk7XG4gICAgICAgIGN1cnZlZExpbmUuZHJhd1BhdGgoY3R4LCB0aGlzLnByb3BzLnhTY2FsZSwgdGhpcy5wcm9wcy5saW5lQ29sb3IsIHRoaXMucHJvcHMubGluZVdpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd1lMYWJlbHMpIHtcbiAgICAgICAgICAgIGN1cnZlZExpbmUuZHJhd1lMYWJlbHMoY3R4LCB2YWx1ZXMsIHRoaXMucHJvcHMubGFiZWxDb2xvciwgdGhpcy5wcm9wcy5sYWJlbFlPZmZzZXQgLSB0aGlzLnByb3BzLmxpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd1hMYWJlbHMpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSB0aGlzLnByb3BzLmxhYmVscy5zcGxpdChcIixcIik7XG4gICAgICAgICAgICBjdXJ2ZWRMaW5lLmRyYXdYTGFiZWxzKGN0eCwgbGFiZWxzLCB0aGlzLnByb3BzLmxhYmVsQ29sb3IsIHRoaXMuY2FudmFzSGVpZ2h0IC0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd0RvdHMpIHtcbiAgICAgICAgICAgIGN1cnZlZExpbmUuZHJhd0RvdHMoY3R4LCB0aGlzLnByb3BzLmRvdENvbG9yLCB0aGlzLnByb3BzLmRvdFNpemUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBwcm9wcyBpZiB0aGVyZSBhcmUgbm9uZVxuLy8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWNvbXBvbmVudC5odG1sI2RlZmF1bHRwcm9wc1xuQ3VydmVkTGluZUdyYXBoLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB3aWR0aDogMzc1LFxuICAgIHBvaW50czogXCIxMCwyMCw2LDM1XCIsXG4gICAgbGFiZWxzOiBcImEsYixjLGRcIixcbiAgICAvLyBHcmFwaFxuICAgIHhTY2FsZTogMTAwLFxuICAgIHlNYXg6IDc1LFxuICAgIHhPZmZzZXQ6IDEwLFxuICAgIC8vIExpbmVcbiAgICBsaW5lQ29sb3I6IFwid2hpdGVcIixcbiAgICBsaW5lV2lkdGg6IDUsXG4gICAgLy8gTGFiZWxzXG4gICAgc2hvd1hMYWJlbHM6IGZhbHNlLFxuICAgIGxhYmVsWENvbG9yOiBcIndoaXRlXCIsXG4gICAgLy8gTGFiZWxzXG4gICAgc2hvd1lMYWJlbHM6IGZhbHNlLFxuICAgIGxhYmVsWU9mZnNldDogLTEwLFxuICAgIGxhYmVsQ29sb3I6IFwid2hpdGVcIixcbiAgICAvLyBTaG93IGRvdHNcbiAgICBzaG93RG90czogZmFsc2UsXG4gICAgZG90U2l6ZTogNCxcbiAgICBkb3RDb2xvcjogXCJ3aGl0ZVwiXG59O1xuLy8gQWRkIEZyYW1lciBVSSBmb3IgdGhpcyBjb21wb25lbnQgKGluIHRoZSBwcm9wZXJ0aWVzIHBhbmVsKVxuLy8gaHR0cHM6Ly9mcmFtZXIuY29tL2xlYXJuL2RvY3MvY29tcG9uZW50cyNjb2RlXG5DdXJ2ZWRMaW5lR3JhcGgucHJvcGVydHlDb250cm9scyA9IHtcbiAgICBwb2ludHM6IHsgdHlwZTogZnJhbWVyXzEuQ29udHJvbFR5cGUuU3RyaW5nLCB0aXRsZTogXCJQb2ludHNcIiB9LFxuICAgIGxhYmVsczogeyB0eXBlOiBmcmFtZXJfMS5Db250cm9sVHlwZS5TdHJpbmcsIHRpdGxlOiBcIkxhYmVsc1wiIH0sXG4gICAgeFNjYWxlOiB7IHR5cGU6IGZyYW1lcl8xLkNvbnRyb2xUeXBlLk51bWJlciwgdGl0bGU6IFwiWCBTY2FsZVwiIH0sXG4gICAgeU1heDogeyB0eXBlOiBmcmFtZXJfMS5Db250cm9sVHlwZS5OdW1iZXIsIHRpdGxlOiBcIlkgTWF4XCIgfSxcbiAgICB4T2Zmc2V0OiB7IHR5cGU6IGZyYW1lcl8xLkNvbnRyb2xUeXBlLk51bWJlciwgdGl0bGU6IFwiWCBPZmZzZXRcIiwgbWluOiAtMTAwMCwgbWF4OiAxMDAwIH0sXG4gICAgbGluZUNvbG9yOiB7IHR5cGU6IGZyYW1lcl8xLkNvbnRyb2xUeXBlLkNvbG9yLCB0aXRsZTogXCJMaW5lIENvbG9yXCIgfSxcbiAgICBsaW5lV2lkdGg6IHsgdHlwZTogZnJhbWVyXzEuQ29udHJvbFR5cGUuTnVtYmVyLCB0aXRsZTogXCJMaW5lIFdpZHRoXCIgfSxcbiAgICBzaG93WUxhYmVsczogeyB0eXBlOiBmcmFtZXJfMS5Db250cm9sVHlwZS5Cb29sZWFuLCB0aXRsZTogXCJZIExhYmVsc1wiIH0sXG4gICAgbGFiZWxZT2Zmc2V0OiB7IHR5cGU6IGZyYW1lcl8xLkNvbnRyb2xUeXBlLk51bWJlciwgdGl0bGU6IFwiWSBPZmZzZXRcIiwgbWluOiAtNTAsIG1heDogNTAsXG4gICAgICAgIGhpZGRlbihwcm9wcykgeyB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTsgcmV0dXJuIHByb3BzLnNob3dZTGFiZWxzID09IGZhbHNlOyB9IH0sXG4gICAgc2hvd1hMYWJlbHM6IHsgdHlwZTogZnJhbWVyXzEuQ29udHJvbFR5cGUuQm9vbGVhbiwgdGl0bGU6IFwiWCBMYWJlbHNcIiB9LFxuICAgIGxhYmVsQ29sb3I6IHsgdHlwZTogZnJhbWVyXzEuQ29udHJvbFR5cGUuQ29sb3IsIHRpdGxlOiBcIkxhYmVsIENvbG9yXCIsXG4gICAgICAgIGhpZGRlbihwcm9wcykgeyB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTsgcmV0dXJuICEocHJvcHMuc2hvd1hMYWJlbHMgPT0gdHJ1ZSB8fCBwcm9wcy5zaG93WUxhYmVscyA9PSB0cnVlKTsgfVxuICAgIH0sXG4gICAgc2hvd0RvdHM6IHsgdHlwZTogZnJhbWVyXzEuQ29udHJvbFR5cGUuQm9vbGVhbiwgdGl0bGU6IFwiU2hvdyBEb3RzXCIsXG4gICAgfSxcbiAgICBkb3RTaXplOiB7IHR5cGU6IGZyYW1lcl8xLkNvbnRyb2xUeXBlLk51bWJlciwgdGl0bGU6IFwiRG90IFNpemVcIixcbiAgICAgICAgaGlkZGVuKHByb3BzKSB7IHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpOyByZXR1cm4gcHJvcHMuc2hvd0RvdHMgPT0gZmFsc2U7IH1cbiAgICB9LFxuICAgIGRvdENvbG9yOiB7IHR5cGU6IGZyYW1lcl8xLkNvbnRyb2xUeXBlLkNvbG9yLCB0aXRsZTogXCJEb3QgQ29sb3JcIixcbiAgICAgICAgaGlkZGVuKHByb3BzKSB7IHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpOyByZXR1cm4gcHJvcHMuc2hvd0RvdHMgPT0gZmFsc2U7IH1cbiAgICB9LFxufTtcbmV4cG9ydHMuQ3VydmVkTGluZUdyYXBoID0gQ3VydmVkTGluZUdyYXBoO1xuLy8gRGVmaW5lIHNvbWUgc3RhbmRhcmQgQ1NTIGZvciB5b3VyIGNvbXBvbmVudFxuY29uc3Qgc3R5bGUgPSB7XG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICBjb2xvcjogXCIjODg1NUZGXCIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbn07XG5jbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG59XG5jbGFzcyBDdWJpY0N1cnZlU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IoY29udHJvbFBvaW50MSwgY29udHJvbFBvaW50Mikge1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxID0gY29udHJvbFBvaW50MTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyID0gY29udHJvbFBvaW50MjtcbiAgICB9XG59XG5jbGFzcyBDdWJpY0N1cnZlZExpbmUge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFQb2ludHMpIHtcbiAgICAgICAgdGhpcy5maXJzdENvbnRyb2xQb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWNvbmRDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuZGF0YVBvaW50cyA9IFtdO1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgdGhpcy5kYXRhUG9pbnRzID0gZGF0YVBvaW50cztcbiAgICB9XG4gICAgZHJhd1BhdGgoY3R4LCB4U2NhbGUsIGxpbmVDb2xvciwgbGluZVdpZHRoKSB7XG4gICAgICAgIHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgICAgICBsZXQgY29udHJvbFBvaW50cyA9IHRoaXMuY29udHJvbFBvaW50cygpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICAgIHRoaXMuZGF0YVBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gY29udHJvbFBvaW50c1tpIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIGNwMiA9IHNlZ21lbnQuY29udHJvbFBvaW50MjtcbiAgICAgICAgICAgICAgICB2YXIgY3AxID0gc2VnbWVudC5jb250cm9sUG9pbnQxO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMS54LCBjcDEueSwgY3AyLngsIGNwMi55LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgZHJhd1hMYWJlbHMoY3R4LCBsYWJlbHMsIGxhYmVsQ29sb3IsIG9mZnNldCkge1xuICAgICAgICB3aW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMTRweCBTRiBQcm8gRGlzcGxheVwiO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3I7XG4gICAgICAgIHRoaXMuZGF0YVBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgICBpZiAobGFiZWxzW2ldKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxhYmVsc1tpXSwgcG9pbnQueCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYXdZTGFiZWxzKGN0eCwgdmFsdWVzLCBsYWJlbENvbG9yLCBvZmZzZXQpIHtcbiAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgIGN0eC5mb250ID0gXCJib2xkIDE0cHggU0YgUHJvIERpc3BsYXlcIjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yO1xuICAgICAgICB0aGlzLmRhdGFQb2ludHMuZm9yRWFjaCgocG9pbnQsIGkpID0+IHtcbiAgICAgICAgICAgIHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHZhbHVlc1tpXSwgcG9pbnQueCwgcG9pbnQueSArIG9mZnNldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3RG90cyhjdHgsIGRvdENvbG9yLCBkb3RTaXplKSB7XG4gICAgICAgIHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZG90Q29sb3I7XG4gICAgICAgIHRoaXMuZGF0YVBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGRvdFNpemUsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29udHJvbFBvaW50cygpIHtcbiAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgIC8vTnVtYmVyIG9mIFNlZ21lbnRzXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuZGF0YVBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vUDAsIFAxLCBQMiwgUDMgYXJlIHRoZSBwb2ludHMgZm9yIGVhY2ggc2VnbWVudCwgd2hlcmUgUDAgJiBQMyBhcmUgdGhlIGtub3RzIGFuZCBQMSwgUDIgYXJlIHRoZSBjb250cm9sIHBvaW50cy5cbiAgICAgICAgaWYgKGNvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGxldCBQMCA9IHRoaXMuZGF0YVBvaW50c1swXTtcbiAgICAgICAgICAgIGxldCBQMyA9IHRoaXMuZGF0YVBvaW50c1sxXTtcbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIEZpcnN0IENvbnRyb2wgUG9pbnRcbiAgICAgICAgICAgIC8vM1AxID0gMlAwICsgUDNcbiAgICAgICAgICAgIGxldCBQMXggPSAoMiAqIFAwLnggKyBQMy54KSAvIDM7XG4gICAgICAgICAgICBsZXQgUDF5ID0gKDIgKiBQMC55ICsgUDMueSkgLyAzO1xuICAgICAgICAgICAgdGhpcy5maXJzdENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoUDF4LCBQMXkpKTtcbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIHNlY29uZCBDb250cm9sIFBvaW50XG4gICAgICAgICAgICAvL1AyID0gMlAxIC0gUDBcbiAgICAgICAgICAgIGxldCBQMnggPSAoMiAqIFAxeCAtIFAwLngpO1xuICAgICAgICAgICAgbGV0IFAyeSA9ICgyICogUDF5IC0gUDAueSk7XG4gICAgICAgICAgICB0aGlzLnNlY29uZENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoUDJ4LCBQMnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgcmhzQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIC8vQXJyYXkgb2YgQ29lZmZpY2llbnRzXG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgdmFyIGIgPSBbXTtcbiAgICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgICAvL2ZvciBpIGluIDAuLi5jb3VudC0xIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgICAgICAgICAgICAgIHZhciByaHNWYWx1ZVggPSAwO1xuICAgICAgICAgICAgICAgIHZhciByaHNWYWx1ZVkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBQMCA9IHRoaXMuZGF0YVBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgUDMgPSB0aGlzLmRhdGFQb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKDApO1xuICAgICAgICAgICAgICAgICAgICBiLnB1c2goMik7XG4gICAgICAgICAgICAgICAgICAgIGMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICAgICAgLy9yaHMgZm9yIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgcmhzVmFsdWVYID0gUDAueCArIDIgKiBQMy54O1xuICAgICAgICAgICAgICAgICAgICByaHNWYWx1ZVkgPSBQMC55ICsgMiAqIFAzLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gY291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaCgyKTtcbiAgICAgICAgICAgICAgICAgICAgYi5wdXNoKDcpO1xuICAgICAgICAgICAgICAgICAgICBjLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vcmhzIGZvciBsYXN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgcmhzVmFsdWVYID0gOCAqIFAwLnggKyBQMy54O1xuICAgICAgICAgICAgICAgICAgICByaHNWYWx1ZVkgPSA4ICogUDAueSArIFAzLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgICAgIGIucHVzaCg0KTtcbiAgICAgICAgICAgICAgICAgICAgYy5wdXNoKDEpO1xuICAgICAgICAgICAgICAgICAgICByaHNWYWx1ZVggPSA0ICogUDAueCArIDIgKiBQMy54O1xuICAgICAgICAgICAgICAgICAgICByaHNWYWx1ZVkgPSA0ICogUDAueSArIDIgKiBQMy55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaHNBcnJheS5wdXNoKG5ldyBQb2ludChyaHNWYWx1ZVgsIHJoc1ZhbHVlWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9Tb2x2ZSBBeD1CLiBVc2UgVHJpZGlhZ29uYWwgbWF0cml4IGFsZ29yaXRobSBhLmsuYSBUaG9tYXMgQWxnb3JpdGhtXG4gICAgICAgICAgICAvL2ZvciBpIGluIDEuLi5jb3VudC0xIHsgLy9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgICAgICAgICAgICAgIGxldCByaHNWYWx1ZVggPSByaHNBcnJheVtpXS54O1xuICAgICAgICAgICAgICAgIGxldCByaHNWYWx1ZVkgPSByaHNBcnJheVtpXS55O1xuICAgICAgICAgICAgICAgIGxldCBwcmV2UmhzVmFsdWVYID0gcmhzQXJyYXlbaSAtIDFdLng7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZSaHNWYWx1ZVkgPSByaHNBcnJheVtpIC0gMV0ueTtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IGFbaV0gLyBiW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgYjEgPSBiW2ldIC0gbSAqIGNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGJbaV0gPSBiMTtcbiAgICAgICAgICAgICAgICBsZXQgcjJ4ID0gcmhzVmFsdWVYIC0gbSAqIHByZXZSaHNWYWx1ZVg7XG4gICAgICAgICAgICAgICAgbGV0IHIyeSA9IHJoc1ZhbHVlWSAtIG0gKiBwcmV2UmhzVmFsdWVZO1xuICAgICAgICAgICAgICAgIHJoc0FycmF5W2ldID0gbmV3IFBvaW50KHIyeCwgcjJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBGaXJzdCBDb250cm9sIFBvaW50cyAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTGFzdCBjb250cm9sIFBvaW50XG4gICAgICAgICAgICBsZXQgbGFzdENvbnRyb2xQb2ludFggPSByaHNBcnJheVtjb3VudCAtIDFdLnggLyBiW2NvdW50IC0gMV07XG4gICAgICAgICAgICBsZXQgbGFzdENvbnRyb2xQb2ludFkgPSByaHNBcnJheVtjb3VudCAtIDFdLnkgLyBiW2NvdW50IC0gMV07XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q29udHJvbFBvaW50c1tjb3VudCAtIDFdID0gbmV3IFBvaW50KGxhc3RDb250cm9sUG9pbnRYLCBsYXN0Q29udHJvbFBvaW50WSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY291bnQgLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0Q29udHJvbFBvaW50ID0gdGhpcy5maXJzdENvbnRyb2xQb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q29udHJvbFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cm9sUG9pbnRYID0gKHJoc0FycmF5W2ldLnggLSBjW2ldICogbmV4dENvbnRyb2xQb2ludC54KSAvIGJbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250cm9sUG9pbnRZID0gKHJoc0FycmF5W2ldLnkgLSBjW2ldICogbmV4dENvbnRyb2xQb2ludC55KSAvIGJbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RDb250cm9sUG9pbnRzW2ldID0gbmV3IFBvaW50KGNvbnRyb2xQb2ludFgsIGNvbnRyb2xQb2ludFkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vQ29tcHV0ZSBzZWNvbmQgQ29udHJvbCBQb2ludHMgZnJvbSBmaXJzdCAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gY291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBQMyA9IHRoaXMuZGF0YVBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBQMSA9IHRoaXMuZmlyc3RDb250cm9sUG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUDEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRyb2xQb2ludFggPSAoUDMueCArIFAxLngpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRyb2xQb2ludFkgPSAoUDMueSArIFAxLnkpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KGNvbnRyb2xQb2ludFgsIGNvbnRyb2xQb2ludFkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBQMyA9IHRoaXMuZGF0YVBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0UDEgPSB0aGlzLmZpcnN0Q29udHJvbFBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UDEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRyb2xQb2ludFggPSAyICogUDMueCAtIG5leHRQMS54O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udHJvbFBvaW50WSA9IDIgKiBQMy55IC0gbmV4dFAxLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kQ29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludChjb250cm9sUG9pbnRYLCBjb250cm9sUG9pbnRZKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgd2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RDb250cm9sUG9pbnQgPSB0aGlzLmZpcnN0Q29udHJvbFBvaW50c1tpXTtcbiAgICAgICAgICAgIGxldCBzZWNvbmRDb250cm9sUG9pbnQgPSB0aGlzLnNlY29uZENvbnRyb2xQb2ludHNbaV07XG4gICAgICAgICAgICBsZXQgc2VnbWVudCA9IG5ldyBDdWJpY0N1cnZlU2VnbWVudChmaXJzdENvbnRyb2xQb2ludCwgc2Vjb25kQ29udHJvbFBvaW50KTtcbiAgICAgICAgICAgIGNvbnRyb2xQb2ludHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbFBvaW50cztcbiAgICB9XG59XG5leHBvcnRzLl9faW5mb19fID0gW3sgbmFtZTogXCJDdXJ2ZWRMaW5lR3JhcGhcIiwgY2hpbGRyZW46IGZhbHNlLCB0eXBlOiBcImNvbXBvbmVudFwiIH1dO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./code/CurvedBezierGraph.tsx\n");

/***/ }),

/***/ "./code/canvas.tsx":
/*!*************************!*\
  !*** ./code/canvas.tsx ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// WARNING: this file is auto generated, any changes will be lost
const framer_1 = __webpack_require__(/*! framer */ "framer");
const canvas = framer_1.CanvasStore.shared({"children":[]});


/***/ }),

/***/ "./package.js":
/*!********************!*\
  !*** ./package.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// The template for the dynamic webpack entry. Be aware of the variables

const packageJson = __webpack_require__(/*! ./package.json */ "./package.json")

const package = {
    packageJson,
    sourceModules: {},
    dependencies: {},
}

// This is a special webpack thing that watches the whole directory
// https://github.com/webpack/docs/wiki/context
const ctx = __webpack_require__("./code sync recursive \\.(t|j)s(x?)|\\.css$")

ctx.keys().forEach(key => {
    package.sourceModules[key] = () => ctx(key)
})

// The packages are passed in through a template
const packages = {}

                packages["framer"] = () => {
                    var package = {}
                    try {
                        package = __webpack_require__(/*! framer */ "framer")
                    } catch (e) {
                        console.log(e)
                    }
                    package.__framer__ = package.__framer__ || {}
                    package.__framer__.packageJson = {"name":"framer","version":"0.10.10","main":"build/framer.js","author":"Framer","license":"MIT","scripts":{"coverage":"jest --config jest.json --coverage","test":"jest --config jest.json","watch":"jest --config jest.json --watch"},"devDependencies":{"@microsoft/api-documenter":"^1.5.47","@microsoft/api-extractor":"^7","@types/chalk":"^2.2.0","@types/draft-js":"0.10.19","@types/enzyme":"^3.1.10","@types/enzyme-adapter-react-16":"^1.0.3","@types/hsluv":"https://github.com/framer/typed_hsluv#bump","@types/jest":"^23.0.0","@types/jest-diff":"^20.0.0","@types/jest-matcher-utils":"^21.0.1","@types/node":"^9.6.0","@types/react":"^16","@types/react-dom":"^16","cache-loader":"^1.2.2","chalk":"^2.4.1","convert-tsconfig-paths-to-webpack-aliases":"^0.9.2","css.escape":"^1.5.1","draft-js":"0.10.4","enzyme":"^3.3.0","enzyme-adapter-react-16":"^1.1.1","eventemitter3":"^3.1.0","fork-ts-checker-webpack-plugin":"^0.4.1","hoist-non-react-statics":"^2.5.0","hsluv":"^0.0.3","immutable":"^3.8.2","jest":"^23.1.0","jest-diff":"^23.6.0","jest-junit":"^5.2.0","progress-bar-webpack-plugin":"^1.11.0","raf":"^3.4.0","react":"~16.4","react-dev-utils":"^5.0.1","react-dom":"~16.4","semver":"^5.6.0","ts-jest":"^23.10.5","ts-loader":"^4.1.0","typescript":"^3.0.1","watch":"^1.0.2","webpack":"^4.4.1","webpack-cli":"^3.1.2","webpack-dev-server":"^3.1.10","xcssmatrix":"^0.2.2"},"peerDependencies":{"react":"^16.3","react-dom":"^16.3"},"tsdoc":{"tsdocFlavor":"AEDoc"},"framer":{"components":[{"name":"Scroll","children":true,"properties":[{"key":"direction","title":"Direction","kind":"enum","options":["horizontal","vertical","both"]}]},{"name":"Page"},{"name":"Stack"},{"name":"FramerAppleWatch38","type":"device"},{"name":"FramerAppleWatch42","type":"device"},{"name":"FramerSonySmartWatch","type":"device"},{"name":"FramerAppleIPhoneSE","type":"device"},{"name":"FramerAppleIPhone8","type":"device"},{"name":"FramerAppleIPhone8Plus","type":"device"},{"name":"FramerAppleIPhoneXS","type":"device"},{"name":"FramerAppleIPhoneXR","type":"device"},{"name":"FramerAppleIPhoneXSMax","type":"device"},{"name":"FramerGooglePixel2","type":"device"},{"name":"FramerGooglePixel2XL","type":"device"},{"name":"FramerGooglePixel3","type":"device"},{"name":"FramerGooglePixel3XL","type":"device"},{"name":"FramerSamsungNote5","type":"device"},{"name":"FramerSamsungGalaxyS9","type":"device"},{"name":"FramerAppleIPadAir","type":"device"},{"name":"FramerAppleIPadMini","type":"device"},{"name":"FramerAppleIPadPro","type":"device"},{"name":"FramerGoogleNexusTablet","type":"device"},{"name":"FramerMicrosoftSurfacePro3","type":"device"},{"name":"FramerMicrosoftSurfacePro4","type":"device"},{"name":"FramerAppleIMac","type":"device"},{"name":"FramerAppleThunderboltDisplay","type":"device"},{"name":"FramerAppleMacBook","type":"device"},{"name":"FramerAppleMacBookAir","type":"device"},{"name":"FramerAppleMacBookPro","type":"device"},{"name":"FramerDellXPS","type":"device"},{"name":"FramerMicrosoftSurfaceBook","type":"device"},{"name":"FramerSonyW850C","type":"device"},{"name":"FramerStoreArtwork","type":"device"},{"name":"FramerStoreIcon","type":"device"}]}}
                    return package
                }

package.dependencies = packages

exports.__framer__ = package


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: main, license, devDependencies, peerDependencies, framer, author, name, version, default */
/***/ (function(module) {

module.exports = {"main":"dist/index.js","license":"MIT","devDependencies":{"@types/react":"^16.4.16"},"peerDependencies":{"framer":"^0.10","react":"^16.3.0","react-dom":"^16.3.0"},"framer":{"id":"b6c1c1e1-57df-4427-ba2a-dbe99790972d","displayName":"Curved Line Graph"},"author":"Dave Fumberger","name":"@framer/djfumberger.curved-line-graph","version":"1.1.0"};

/***/ }),

/***/ "framer":
/*!******************************************************************************************!*\
  !*** external {"root":"Framer","commonjs2":"framer","commonjs":"framer","amd":"framer"} ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_framer__;

/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ });
});